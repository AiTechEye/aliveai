By AiTechEye
Version: 21
License: CC0

Alive AI

NPC AI mobs that can mine, craft, build, fight, escape, eat, climb+ladders, avoid heights/hurting blocks, use tools, remember enemies, swim/drowning, talk...

The mobs will basically look for stuff it needs, mine, craft, build houses in randomly sizes, materials (depends on its ambient and what it have) with furnitures, and do things it needs to do.

Spawner block (works with mesecons)
aliveai:spawner

aliveai:copy
use to generate building instructions code that the bots can use to build

aliveai:genbuildingtool
generate random buildings (standard buildings)

bots can call bots like: <name> come
players can do: <name> come
and <team> come
default teams are Sam and Jezy ... eg: Sam come

you can also rightclick them instead of call


Commands:
enable/diable bot status
/aliveai status=true
/aliveai status=false
show count of bots
/aliveai count

make them to a guard:
right click them with a diamond, this makes them stay around the position.
useful to keep monsters and enemies away.

====================================================================================
if you want to include this API in/with your mod (make a mod pack, like this):

Mod name
------------mod 1
------------mod 2
------------aliveai
------------depends.txt (add aliveai)
------------modpack.txt (no text needed)
then you can customize bots from your mod scripts without needing to modify the aliveai +no mess with updates.

show hidden tools and status by set status=true,tools=0 in the init.lua
or toogle status on/of by /aliveai status=true/false

====================================================================================
Save/load
Do not save strings that contents the characters:   ,*?

to save or load settings do you have to add functions that will be used when bots are load or unload
inside: aliveai.loaddata and aliveai.savedata

you can return
Variables with numbers/strings
and Tables with with numbers/strings
but not a variable or table that contents a table

aliveai.savedata.name=function(self)
	if self.notes then
		return {
			skin=self.skin,
			num=self.num,
			notes={note1=1,note2="text"}
		}
	end
end

return loaded data from r

aliveai.loaddata.name=function(self,r)
	if r.notes then
		if r.skin then self.skin=r.skin
		self.num=r.num or 0
		self.notes=r.notes or {}
	end
	return self
end
====================================================================================
Standard and adjustable values in aliveai.create_bot()
The settings are using "1 or 0" instead of "true or false"

create bots through, e.g: aliveai.create_bot({name="alien",dmg=5,team="alienteam3",fighting=1})
self		nil	self={money=25,items={axe=1,dirt="abc"},lifes=3}
aliveai			[all bots gets the variable]
dropbones	1	place bones, if its enabled
name		"bot"	(registry name)
botname		""	(the bots name)
name_color	ffffff	("" to hide name)
hp		20
drop_dead_body	1
creative		0	creative
superbuild	0	can build on distance
crafting		1	(craft things, also on its own way)
visual		mesh	(drawtype, like "cube")
basey		0.7	(used to check if a bot are inside a block then jump)
spawn_y		0	(change y pos on spawn)
check_spawn_space1	
house		""	(house code generated by aliveai:building)
collisionbox	player standard
visual_size	player standard
texture		"character.png"
dmg		4	(damage)
avoid_height	6	(avoid height or hurts after)
arm		5	(range it can reach)
distance		15	(range it can read its environment)
team			name like "aliveai43",
type		"npc"
start_with_items	""	{["default:wood"]=100,["default:dirt"]=5} (this bots do not have "drops" llike common mobs, only a unlimited inventory)
tools		""	{"bows:arrow","bows:bow_steel"}  (tools and items the bot can use, can return object or nothing, the tools will be restored after every use)
tool_index	1	index of tool [with .on_use] to use
tool_reuse	0	use the tool 2 times (used e.g loading a bow)
tool_near		0	(use the tool when the enimy is near)
tool_see		1	(use the tool when the enemy is visible)
tool_chance	5	(use the tool randomly, 1 is constantly)
escape		1	(escape if something takes 50% of its health)
fighting		1	(if something punch it
attack_players	0	(attack players because it is hurted)
attack_chance	10	(search objects to fight)
smartfight	1	(moves randomly and jumping = harder)
building		1	(houses)
pickuping		1	(walks to/picks up items)
attacking		0	(attacking without reason)
coming		1	(can come if bots or players says <name> come)
work_helper	0	gives all their stuff (exepttools) to other bots that have some more stuff.
coming_players	1	(can come if players says <name> come)
talking		1	(can talk in chat and listen)
stealing		0	(steal from players, 1 for Jezzy) 
steal_chanse	0	(0=no chanse)
light		1	 1=search to light, -1=search to darknes 0=ignore light
lowest_light	10	enough light
spawn_interval	300
spawn_chance	1000
spawn_in		"air"
spawn_on		{"group:dirt","group:sand","default:snow"},
hurts_by_light	1	(hurts when inside light, and depends on its position, like stuck in a dark cave in underground)
annoyed_by_staring 1	(attacks objects if them are near it after a while)
drowning		1
usearmor		1	use the armor and wieldview
kill_deep_falling	1	kills the bot, when they are falling and becomes inactivated
leader		0	can command bots in bigger extent
damage_by_blocks	1	hurted by blocks like lava, fire, toxic...
on_step=function(self,dtime)
	return self
end

on_fighting		self,target
on_escaping		self,target
on_punching		self,target
on_detect_enemy		self,target
on_detecting_enemy	self,target
death			self,puncher,pos
spawn			self
on_load			self
on_random_walk		self
click			self,clicker
on_punched		self,puncher,dmg
on_meet			self,target
on_spoken_to		self,name,speaker,msg
on_step			self,dtime			(return ssomething to abort the bot run, like if it need to folow a path or stand still)
on_dig			self,pos,drop,number
on_blow			self			when a bot get hurt by explosion
================== tasks (is called when everything else is done) (return something to exit the bot run) (task1 is buildning as default) (task2 is "stay at home" as default)
================== self.task (string) and self.taskstep (number) is usefull for this
task1			self
task2			self
task3			self
task4			self
task5			self
================== storge variables, can contain a string, int and inventory
self.storge1
self.storge2
self.storge3
self.storge4
self.storge5
====================================================================================
Usefull functions

aliveai.viewfield(self,object_or_pos)		if is front of it
aliveai.visiable(self,pos2)			if the view not are blocked
aliveai.distance(self_or_pos,pos)		self can be a position too
aliveai.pointat(self,distance)			returns a position front of the bot, distance can be nil

aliveai.kill(self)				kill the bot
aliveai.gethp(object)			get hp/health and get_hp() value
aliveai.showhp(self,p)			p: nil=green or red
aliveai.showtext(self,text,hexcolor)		"ff0000" is red, "00ff00" are green, nil are also green

aliveai.rndwalk(self,toogle)			toogle: nil=on, true=off
aliveai.walk(self,sp)			sp: nil or speed number (defaults: 1=walk,2=run)
aliveai.stand(self)				stand still
aliveai.jump(self,velocity)			nil or {y,x,z}
aliveai.punch(self,object,hp)
aliveai.lookat(self,pos)
aliveai.get_dir(self_or_pos,object_or_pos)

aliveai.anim(self,type)			type can be: "stand", "lay", "walk", "mine", "walk_mine", "sit"
aliveai.say(self,text)
aliveai.get_bot_by_name(name)
aliveai.known(self,object,type)		add value by object name, if its known as something
aliveai.getknown(self,object,type)
aliveai.searchhelp(self)			call bots from same team
aliveai.samepos(pos1,pos2)			if positions is same or very near
aliveai.roundpos(pos)

aliveai.random_pos(self,Min,Max)		self or position, min distance max distance: returns a randomly position where you can stand on
aliveai.get_nodes(self,radio,dencity,filter)	self,radio size,dencity, filter (nodes to not list)

aliveai.namecut(name,group)			cuts down a name, if its able (like default:wood / group:wood to w), if group is true return cut to group (like w to group:wood)
aliveai.generate_house(self)			generate house instructions
aliveai.showpath(pos,number,pos_is_a_table)	works if aliveai.status=true, number can be 1,2,3 pos_is_a_table can be true or nil
aliveai.showstatus(self,text,color)		works if aliveai.status=true, color can be 1,2,3,4 (tempoary change the nametag)

aliveai.team(object,change_to_team)		get object team, object or set team
aliveai.save(name,data)			string/name, table/variable to save
aliveai.load(name)				string/name to load
====================================================================================
bot
aliveai.get_bot_by_name(name)		return bot object by name or nil
aliveai.same_bot(self,object)			checks if the object is it self
aliveai.get_bot_name(object)			return bot name or ""
aliveai.is_bot(object)			true or false
====================================================================================
items
aliveai.invadd(self,item,number,nfeedback)	add or remove to to inventory, nfeedback=no autocraft (can be nil)
aliveai.invhave(self,item,number,getnum)	if have in inventory (getnum = get number of the item, can be nil)
aliveai.newneed(self,item,num,search,type)	add items the bot need by some reason, item, number, search for type (item or node) search and type can be nil
aliveai.haveneed(self,craft)			have items that needs, craft= craft if not have needs
aliveai.place(self,pos,name)			place node
aliveai.dig(self,pos)				dig node
aliveai.eat(self,name)			try to eat an item
aliveai.spawnpickup(pos,item,number)		spawn item
aliveai.invdropall(self)			drop all items
aliveai.use(self)				use tool in self.tools
aliveai.add_mine(self,nodes,count,need)	begin or add to mine (self,table,number,string_or_table) 
aliveai.exit_mine(self)			exit mine
====================================================================================
paths
aliveai.exitpath(self)			exit path walking
aliveai.path(self,near			walk on path (returns self.done="done" if finished or does self.path=nili if feiled)
aliveai.creatpath(self,pos1,pos2,distance,not_advanced) (set as self.path=path to make it work)
